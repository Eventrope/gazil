extends Node

# BotManager - Manages bot opponents and their AI decisions

const BOT_MARKET_IMPACT := 0.5  # Bot trades affect market at 50% strength

var bots: Array = []  # Array of Bot
var difficulty: String = "medium"
var game_length: int = 200
var debug_mode: bool = false
var bot_news: Array = []  # News items generated by bot actions

signal bot_action(bot: Bot, action: String, details: Dictionary)
signal bot_eliminated(bot: Bot)
signal news_generated(headline: String, details: Dictionary)

func _ready() -> void:
	pass

func initialize_bots(bot_count: int, game_difficulty: String) -> void:
	bots.clear()
	bot_news.clear()
	difficulty = game_difficulty

	var bot_data_list: Array = DataRepo.get_all_bots()
	if bot_data_list.is_empty():
		push_error("BotManager: No bot data found")
		return

	# Shuffle and pick bots
	bot_data_list.shuffle()
	bot_count = mini(bot_count, bot_data_list.size())

	for i in range(bot_count):
		var bot: Bot = Bot.create(bot_data_list[i], difficulty)
		bot.eliminated.connect(_on_bot_eliminated.bind(bot))
		bots.append(bot)

	print("BotManager: Initialized %d bots at %s difficulty" % [bot_count, difficulty])

func _on_bot_eliminated(bot: Bot) -> void:
	bot_eliminated.emit(bot)
	_generate_news("bankruptcy", bot, {})

func get_active_bots() -> Array:
	var active: Array = []
	for bot in bots:
		if not bot.is_eliminated:
			active.append(bot)
	return active

func get_bot_count() -> int:
	return get_active_bots().size()

func process_bot_turns(days: int) -> Array:
	# Process all bot actions for the given number of days
	# Returns array of actions taken for news feed
	var actions: Array = []

	for _day in range(days):
		for bot in bots:
			if bot.is_eliminated:
				continue

			# Check if traveling
			if bot.is_traveling():
				var arrived: bool = bot.advance_travel(1)
				if arrived:
					# Bot arrived, remember prices at new location
					_update_bot_memory(bot)
					# Maybe trigger an event
					_maybe_trigger_bot_event(bot)
			else:
				# Bot is at port, make decisions
				var action: Dictionary = _process_bot_decision(bot)
				if not action.is_empty():
					actions.append(action)

			# Check for bankruptcy
			if bot.is_bankrupt():
				bot.eliminate()

	return actions

func _process_bot_decision(bot: Bot) -> Dictionary:
	# Main AI decision loop
	var decision: Dictionary = _make_decision(bot)

	if debug_mode:
		print("[DEBUG] %s Decision:" % bot.bot_name)
		print("  Location: %s, Credits: %d, Fuel: %d" % [bot.current_planet, bot.credits, bot.fuel])
		print("  Cargo: %s" % str(bot.cargo))
		print("  Decision: %s" % str(decision))

	# Execute the decision
	match decision["action"]:
		"sell":
			return _execute_sell(bot, decision)
		"buy":
			return _execute_buy(bot, decision)
		"travel":
			return _execute_travel(bot, decision)
		"refuel":
			return _execute_refuel(bot, decision)
		"wait":
			return {"bot": bot, "action": "wait", "details": {}}

	return {}

func _make_decision(bot: Bot) -> Dictionary:
	# Decision priority:
	# 1. Refuel if critically low
	# 2. Sell cargo if profitable at current location
	# 3. Buy cargo if good opportunity
	# 4. Travel to better location

	var personality: Dictionary = _get_personality_modifiers(bot)

	# 1. Check fuel
	var fuel_ratio: float = float(bot.fuel) / float(bot.fuel_capacity)
	if fuel_ratio < 0.3:
		return {"action": "refuel", "amount": bot.fuel_capacity - bot.fuel}

	# 2. Check if should sell
	var sell_decision: Dictionary = _evaluate_sell(bot, personality)
	if sell_decision["should_sell"]:
		return {"action": "sell", "commodity": sell_decision["commodity"], "quantity": sell_decision["quantity"]}

	# 3. Check if should buy
	var buy_decision: Dictionary = _evaluate_buy(bot, personality)
	if buy_decision["should_buy"]:
		return {"action": "buy", "commodity": buy_decision["commodity"], "quantity": buy_decision["quantity"]}

	# 4. Decide where to travel
	var travel_decision: Dictionary = _evaluate_travel(bot, personality)
	if travel_decision["should_travel"]:
		return {"action": "travel", "destination": travel_decision["destination"]}

	# 5. Default: wait (Vultures do this often)
	return {"action": "wait"}

func _get_personality_modifiers(bot: Bot) -> Dictionary:
	match bot.personality:
		Bot.Personality.VULTURE:
			return {
				"min_profit_margin": 0.40,
				"max_travel_distance": 999,  # Any distance
				"cash_reserve_ratio": 0.50,
				"will_wait": true,
				"prefers_volatility": true
			}
		Bot.Personality.SPEEDRUNNER:
			return {
				"min_profit_margin": 0.10,
				"max_travel_distance": 3,
				"cash_reserve_ratio": 0.20,
				"will_wait": false,
				"prefers_volatility": false
			}
		Bot.Personality.GAMBLER:
			return {
				"min_profit_margin": 0.05,
				"max_travel_distance": 999,
				"cash_reserve_ratio": 0.0,
				"will_wait": false,
				"prefers_volatility": true
			}
		_:  # STEADY
			return {
				"min_profit_margin": 0.25,
				"max_travel_distance": 5,
				"cash_reserve_ratio": 0.40,
				"will_wait": true,
				"prefers_volatility": false
			}

func _evaluate_sell(bot: Bot, personality: Dictionary) -> Dictionary:
	# Check if any cargo should be sold at current location
	var best_sell: Dictionary = {"should_sell": false, "commodity": "", "quantity": 0, "profit_margin": 0.0}

	for commodity_id in bot.cargo:
		var quantity: int = bot.cargo[commodity_id]
		if quantity <= 0:
			continue

		var current_price: int = GameState.get_price_at(bot.current_planet, commodity_id)
		var remembered_buy_price: int = _get_avg_buy_price(bot, commodity_id)

		if remembered_buy_price <= 0:
			remembered_buy_price = current_price  # Assume break-even if unknown

		var profit_margin: float = float(current_price - remembered_buy_price) / float(remembered_buy_price)

		# Gamblers sometimes sell at a loss to free up capital
		var min_margin: float = personality["min_profit_margin"]
		if bot.personality == Bot.Personality.GAMBLER and randf() < 0.2:
			min_margin = -0.1  # Accept 10% loss sometimes

		if profit_margin >= min_margin:
			if profit_margin > best_sell["profit_margin"]:
				best_sell = {
					"should_sell": true,
					"commodity": commodity_id,
					"quantity": quantity,
					"profit_margin": profit_margin
				}

	return best_sell

func _get_avg_buy_price(bot: Bot, commodity_id: String) -> int:
	# Estimate what the bot paid for this cargo
	# Use memory of prices from where they likely bought
	var lowest_price := 999999
	for planet_id in bot.price_memory:
		if bot.price_memory[planet_id].has(commodity_id):
			var price: int = bot.price_memory[planet_id][commodity_id]["price"]
			if price < lowest_price:
				lowest_price = price
	return lowest_price if lowest_price < 999999 else 0

func _evaluate_buy(bot: Bot, personality: Dictionary) -> Dictionary:
	# Check if should buy something at current location
	var best_buy: Dictionary = {"should_buy": false, "commodity": "", "quantity": 0, "expected_profit": 0}

	var reserve: int = int(bot.credits * personality["cash_reserve_ratio"])
	var available_credits: int = bot.credits - reserve
	var cargo_space: int = bot.get_cargo_space_free()

	if available_credits <= 0 or cargo_space <= 0:
		return best_buy

	for commodity_id in DataRepo.get_all_commodity_ids():
		var current_price: int = GameState.get_price_at(bot.current_planet, commodity_id)
		var stock: int = GameState.get_stock_at(bot.current_planet, commodity_id)
		var commodity: Commodity = DataRepo.get_commodity(commodity_id)

		if stock <= 0 or commodity == null:
			continue

		# Find best remembered sell price
		var best_sell_price: Dictionary = _find_best_sell_planet(bot, commodity_id, current_price)

		if best_sell_price["price"] <= current_price:
			continue  # No profitable sale known

		var profit_margin: float = float(best_sell_price["price"] - current_price) / float(current_price)

		if profit_margin < personality["min_profit_margin"]:
			continue

		# Check if destination is within travel preference
		var distance: int = _get_distance(bot.current_planet, best_sell_price["planet"])
		var max_distance: int = personality["max_travel_distance"]
		if max_distance > 0 and distance > max_distance:
			continue

		# Calculate quantity to buy
		var weight_per_unit: int = commodity.weight_per_unit
		var max_by_space: int = cargo_space / weight_per_unit
		var max_by_credits: int = available_credits / current_price
		var max_by_stock: int = stock
		var quantity: int = mini(mini(max_by_space, max_by_credits), max_by_stock)

		if quantity <= 0:
			continue

		var expected_profit: int = (best_sell_price["price"] - current_price) * quantity

		if expected_profit > best_buy["expected_profit"]:
			best_buy = {
				"should_buy": true,
				"commodity": commodity_id,
				"quantity": quantity,
				"expected_profit": expected_profit,
				"target_planet": best_sell_price["planet"]
			}

	return best_buy

func _find_best_sell_planet(bot: Bot, commodity_id: String, buy_price: int) -> Dictionary:
	var best: Dictionary = {"planet": "", "price": 0}

	# Check memory first
	for planet_id in bot.price_memory:
		if bot.price_memory[planet_id].has(commodity_id):
			var price: int = bot.price_memory[planet_id][commodity_id]["price"]
			if price > best["price"]:
				best = {"planet": planet_id, "price": price}

	# If no memory, check current prices (bots have some market knowledge)
	if best["price"] <= buy_price:
		for planet_id in DataRepo.get_all_planet_ids():
			var planet: Planet = DataRepo.get_planet(planet_id)
			if planet == null or not planet.is_unlocked(GameState.player.day if GameState.player else 1):
				continue
			var price: int = GameState.get_price_at(planet_id, commodity_id)
			if price > best["price"]:
				best = {"planet": planet_id, "price": price}

	return best

func _evaluate_travel(bot: Bot, personality: Dictionary) -> Dictionary:
	# Decide where to travel next
	var best: Dictionary = {"should_travel": false, "destination": "", "score": -999999.0}

	var current_day: int = GameState.player.day if GameState.player else 1

	for planet_id in DataRepo.get_all_planet_ids():
		if planet_id == bot.current_planet:
			continue

		var planet: Planet = DataRepo.get_planet(planet_id)
		if planet == null or not planet.is_unlocked(current_day):
			continue

		if not GameState.is_planet_accessible(planet_id):
			continue

		var distance: int = _get_distance(bot.current_planet, planet_id)

		# Check travel distance preference
		var max_distance: int = personality["max_travel_distance"]
		if max_distance > 0 and distance > max_distance:
			continue

		# Check fuel
		var fuel_cost: int = bot.get_fuel_cost(distance)
		if bot.fuel < fuel_cost:
			continue

		# Score this destination
		var score: float = _score_destination(bot, planet_id, distance, personality)

		if score > best["score"]:
			best = {"should_travel": true, "destination": planet_id, "score": score}

	# Vultures and Steady personalities might choose to wait
	if not best["should_travel"] or (personality["will_wait"] and best["score"] < 100):
		if randf() < 0.3:  # 30% chance to wait
			return {"should_travel": false}

	return best

func _score_destination(bot: Bot, planet_id: String, distance: int, personality: Dictionary) -> float:
	var score := 0.0

	# If carrying cargo, score based on sale opportunity
	if not bot.cargo.is_empty():
		for commodity_id in bot.cargo:
			var current_price: int = GameState.get_price_at(bot.current_planet, commodity_id)
			var dest_price: int = GameState.get_price_at(planet_id, commodity_id)
			var quantity: int = bot.cargo[commodity_id]
			var profit: int = (dest_price - current_price) * quantity
			score += profit

	# Score based on buying opportunities there
	for commodity_id in DataRepo.get_all_commodity_ids():
		var dest_price: int = GameState.get_price_at(planet_id, commodity_id)
		var best_sell: Dictionary = _find_best_sell_planet(bot, commodity_id, dest_price)
		if best_sell["price"] > dest_price:
			var margin: float = float(best_sell["price"] - dest_price) / float(dest_price)
			score += margin * 100  # Weight by margin

	# Penalty for distance (speedrunners hate long trips)
	var distance_penalty: float = distance * 10.0
	if bot.personality == Bot.Personality.SPEEDRUNNER:
		distance_penalty *= 3.0
	score -= distance_penalty

	# Gamblers get bonus for volatile planets
	if personality["prefers_volatility"]:
		var planet: Planet = DataRepo.get_planet(planet_id)
		if planet:
			score += planet.supply_volatility * 50

	return score

func _get_distance(from_planet: String, to_planet: String) -> int:
	var planet: Planet = DataRepo.get_planet(from_planet)
	if planet == null:
		return 999
	return planet.get_distance_to(to_planet)

func _execute_sell(bot: Bot, decision: Dictionary) -> Dictionary:
	var commodity_id: String = decision["commodity"]
	var quantity: int = decision["quantity"]
	var price: int = GameState.get_price_at(bot.current_planet, commodity_id)
	var total_value: int = price * quantity

	bot.remove_cargo(commodity_id, quantity)
	bot.add_credits(total_value)
	bot.statistics["trades_made"] += 1

	# Partial market impact
	var impact_quantity: int = int(quantity * BOT_MARKET_IMPACT)
	GameState._modify_stock(bot.current_planet, commodity_id, impact_quantity)

	var action: Dictionary = {
		"bot": bot,
		"action": "sell",
		"details": {
			"commodity": commodity_id,
			"quantity": quantity,
			"price": price,
			"total": total_value,
			"planet": bot.current_planet
		}
	}

	bot_action.emit(bot, "sell", action["details"])

	# Generate news for major trades
	if total_value >= 500:
		_generate_news("major_sell", bot, action["details"])

	return action

func _execute_buy(bot: Bot, decision: Dictionary) -> Dictionary:
	var commodity_id: String = decision["commodity"]
	var quantity: int = decision["quantity"]
	var price: int = GameState.get_price_at(bot.current_planet, commodity_id)
	var total_cost: int = price * quantity

	# Check stock
	var stock: int = GameState.get_stock_at(bot.current_planet, commodity_id)
	quantity = mini(quantity, stock)

	if quantity <= 0 or not bot.spend_credits(total_cost):
		return {}

	bot.add_cargo(commodity_id, quantity)
	bot.remember_price(bot.current_planet, commodity_id, price, GameState.player.day if GameState.player else 1)
	bot.statistics["trades_made"] += 1

	# Partial market impact
	var impact_quantity: int = int(quantity * BOT_MARKET_IMPACT)
	GameState._modify_stock(bot.current_planet, commodity_id, -impact_quantity)

	var action: Dictionary = {
		"bot": bot,
		"action": "buy",
		"details": {
			"commodity": commodity_id,
			"quantity": quantity,
			"price": price,
			"total": total_cost,
			"planet": bot.current_planet
		}
	}

	bot_action.emit(bot, "buy", action["details"])

	# Generate news for major trades
	if total_cost >= 500:
		_generate_news("major_buy", bot, action["details"])

	return action

func _execute_travel(bot: Bot, decision: Dictionary) -> Dictionary:
	var destination: String = decision["destination"]
	var distance: int = _get_distance(bot.current_planet, destination)

	bot.start_travel(destination, distance)

	var action: Dictionary = {
		"bot": bot,
		"action": "travel",
		"details": {
			"from": bot.current_planet,
			"destination": destination,
			"distance": distance
		}
	}

	bot_action.emit(bot, "travel", action["details"])

	return action

func _execute_refuel(bot: Bot, decision: Dictionary) -> Dictionary:
	var amount: int = decision["amount"]
	var fuel_price: int = GameState.get_fuel_price_at(bot.current_planet)
	var cost: int = amount * fuel_price

	# Buy what we can afford
	if bot.credits < cost:
		amount = bot.credits / fuel_price
		cost = amount * fuel_price

	if amount <= 0:
		return {}

	bot.spend_credits(cost)
	bot.add_fuel(amount)

	return {
		"bot": bot,
		"action": "refuel",
		"details": {"amount": amount, "cost": cost}
	}

func _update_bot_memory(bot: Bot) -> void:
	# When bot arrives at planet, remember current prices
	var current_day: int = GameState.player.day if GameState.player else 1

	for commodity_id in DataRepo.get_all_commodity_ids():
		var price: int = GameState.get_price_at(bot.current_planet, commodity_id)
		bot.remember_price(bot.current_planet, commodity_id, price, current_day)

	# Also forget old prices
	bot.forget_old_prices(current_day)

func _maybe_trigger_bot_event(bot: Bot) -> void:
	# 35% chance of event (same as player)
	if randf() > 0.35:
		return

	# Roll for event type
	var roll: float = randf()

	if roll < 0.4:
		# Cargo loss (pirates/asteroid)
		if bot.cargo.is_empty():
			return
		var cargo_types: Array = bot.cargo.keys()
		var commodity_id: String = cargo_types[randi() % cargo_types.size()]
		var quantity: int = bot.cargo[commodity_id]
		var loss: int = randi_range(int(quantity * 0.2), int(quantity * 0.5))
		loss = maxi(1, loss)

		bot.remove_cargo(commodity_id, loss)
		bot.statistics["events_survived"] += 1

		_generate_news("event_loss", bot, {
			"commodity": commodity_id,
			"quantity": loss,
			"location": bot.current_planet
		})

	elif roll < 0.6:
		# Credit gain (salvage/discovery)
		var gain: int = randi_range(50, 200)
		bot.add_credits(gain)
		bot.statistics["events_survived"] += 1

	else:
		# Nothing significant
		bot.statistics["events_survived"] += 1

func _generate_news(news_type: String, bot: Bot, details: Dictionary) -> void:
	var templates: Array = DataRepo.get_bot_news_templates(news_type)
	if templates.is_empty():
		return

	var template: String = templates[randi() % templates.size()]

	# Replace placeholders
	template = template.replace("{name}", bot.bot_name)
	template = template.replace("{quantity}", str(details.get("quantity", 0)))
	template = template.replace("{commodity}", _format_commodity_name(details.get("commodity", "")))
	template = template.replace("{planet}", _format_planet_name(details.get("planet", "")))
	template = template.replace("{destination}", _format_planet_name(details.get("destination", "")))
	template = template.replace("{location}", _format_planet_name(details.get("location", "")))
	template = template.replace("{days}", str(details.get("distance", 0)))

	var news_item: Dictionary = {
		"headline": template,
		"type": news_type,
		"bot": bot,
		"day": GameState.player.day if GameState.player else 1,
		"details": details
	}

	bot_news.append(news_item)
	news_generated.emit(template, details)

func _format_commodity_name(commodity_id: String) -> String:
	var commodity: Commodity = DataRepo.get_commodity(commodity_id)
	if commodity:
		return commodity.commodity_name
	return commodity_id.capitalize()

func _format_planet_name(planet_id: String) -> String:
	var planet: Planet = DataRepo.get_planet(planet_id)
	if planet:
		return planet.planet_name
	return planet_id.capitalize()

func get_recent_news(count: int = 10) -> Array:
	var news: Array = bot_news.duplicate()
	news.reverse()
	return news.slice(0, count)

func clear_news() -> void:
	bot_news.clear()

func get_leaderboard() -> Array:
	# Returns sorted array of {entity, credits, is_player}
	var entries: Array = []

	# Add player
	if GameState.player:
		entries.append({
			"name": "You",
			"credits": GameState.player.get_net_worth(),
			"is_player": true,
			"location": GameState.player.current_planet,
			"is_eliminated": false
		})

	# Add bots
	for bot in bots:
		entries.append({
			"name": bot.bot_name,
			"credits": bot.get_net_worth(),
			"is_player": false,
			"location": bot.current_planet if not bot.is_traveling() else "In Transit",
			"is_eliminated": bot.is_eliminated,
			"color": bot.color
		})

	# Sort by credits (descending)
	entries.sort_custom(func(a, b): return a["credits"] > b["credits"])

	# Add rank
	for i in range(entries.size()):
		entries[i]["rank"] = i + 1

	return entries

func to_dict() -> Dictionary:
	var bots_data: Array = []
	for bot in bots:
		bots_data.append(bot.to_dict())

	return {
		"bots": bots_data,
		"difficulty": difficulty,
		"game_length": game_length,
		"debug_mode": debug_mode,
		"bot_news": bot_news.duplicate(true)
	}

func from_dict(data: Dictionary) -> void:
	bots.clear()
	difficulty = data.get("difficulty", "medium")
	game_length = data.get("game_length", 200)
	debug_mode = data.get("debug_mode", false)
	bot_news = data.get("bot_news", [])

	var bots_data: Array = data.get("bots", [])
	for bot_data in bots_data:
		var bot: Bot = Bot.from_dict(bot_data)
		bot.eliminated.connect(_on_bot_eliminated.bind(bot))
		bots.append(bot)
